////  PatientObject.m//  Mobile Clinic////  Created by Steven Berlanga on 2/4/13.//  Copyright (c) 2013 Steven Berlanga. All rights reserved.//#define PATIENTID   @"patientId"#define ALLPATIENTS @"all patients"#define DATABASE    @"Patients"#import "PatientObject.h"#import "StatusObject.h"#import "VisitationObject.h"#import "Patients.h"#import "UIImage+ImageVerification.h"StatusObject* tempStatusObject;Patients* patient;VisitationObject* currentVisit;@implementation PatientObject+(NSString*)DatabaseName{    return DATABASE;}#pragma mark- Protocol Methods#pragma mark--(NSDictionary *)consolidateForTransmitting:(NSManagedObject *)object{        NSMutableDictionary* consolidate = [[NSMutableDictionary alloc]initWithDictionary:[super consolidateForTransmitting]];    [consolidate setValue:[NSNumber numberWithInt:kPatientType] forKey:OBJECTTYPE];    return consolidate;}-(void)unpackageFileForUser:(NSDictionary *)data{    [super unpackageFileForUser:data];    [self linkPatient];    [patient setValuesForKeysWithDictionary:[data objectForKey:DATABASEOBJECT]];    }-(void)saveObject:(ObjectResponse)eventResponse{    // Database object needs to exist    if (patient){        [super SaveAndRefreshObjectToDatabase:self.databaseObject];        eventResponse(self,nil);    }else{        eventResponse(Nil,[self createErrorWithDescription:@"No Patient has been selected" andErrorCodeNumber:0 inDomain:@"Patient Object"]);    }}-(void)setDBObject:(NSManagedObject *)databaseObject{    [super setDBObject:databaseObject];    [self linkPatient];    }#pragma mark- Public Methods#pragma mark--(void)UpdatePatientObject:(ObjectResponse)response{        respondToEvent = response;        [patient setIsLockedBy:@""];        [self saveObject:^(id<BaseObjectProtocol> data, NSError *error) {        if (error) {            respondToEvent(nil,error);        }else{                        NSMutableDictionary* dataToSend = [NSMutableDictionary dictionaryWithDictionary:[self consolidateForTransmitting:patient]];            [dataToSend setValue:[NSNumber numberWithInteger:kUpdateObject] forKey:OBJECTCOMMAND];            [dataToSend setValue:[NSNumber numberWithInteger:kPatientType] forKey:OBJECTTYPE];            [dataToSend setValue:self.appDelegate.currentUserName forKey:ISLOCKEDBY];                        [self tryAndSendData:dataToSend withErrorToFire:^(id<BaseObjectProtocol> data, NSError *error) {                respondToEvent(nil,error);            } andWithPositiveResponse:^(id data) {                respondToEvent(self,nil);            }];        }    }];}-(NSString *)description{    NSString* text = [NSString stringWithFormat:@"\nFirst Name: %@ \nLast Name: %@ \nVillage %@\nObjectType: %i",patient.firstName,patient.familyName,patient.villageName, self.objectType];    return text;}-(NSArray *)FindAllPatientsLocallyWithFirstName:(NSString *)firstname andWithLastName:(NSString *)lastname{    NSPredicate* pred = [NSPredicate predicateWithFormat:@"%K contains[cd] %@ || %K contains[cd] %@",FIRSTNAME,firstname,FAMILYNAME,lastname];        return [self FindObjectInTable:DATABASE withCustomPredicate:pred andSortByAttribute:FIRSTNAME];}-(void)FindAllPatientsOnServerWithFirstName:(NSString *)firstname andWithLastName:(NSString *)lastname onCompletion:(ObjectResponse)eventResponse{        respondToEvent = eventResponse;        NSMutableDictionary* query = [[NSMutableDictionary alloc]initWithCapacity:4];        [query setValue:[NSNumber numberWithInt:kPatientType] forKey:OBJECTTYPE];    [query setValue:[NSNumber numberWithInt:kFindObject] forKey:OBJECTCOMMAND];        [query setValue:firstname forKey:FIRSTNAME];    [query setValue:lastname forKey:FAMILYNAME];        [ self tryAndSendData:query withErrorToFire:^(id<BaseObjectProtocol> data, NSError *error) {        [self QueryForPatientActionSuccessfull:nil];    } andWithPositiveResponse:^(id data) {        [self QueryForPatientActionSuccessfull:data];    }];}-(void)createNewPatient:(ObjectResponse)onSuccessHandler{        [self.databaseObject setValue:@"" forKey:ISLOCKEDBY];        [self.databaseObject setValue:[NSNumber numberWithBool:YES] forKey:STATUS];        // validate patient info and creates a patient ID    if ([self isValidateIfPatientInformationIsPresent]) {                [self saveObject:^(id<BaseObjectProtocol> data, NSError *error) {            onSuccessHandler(data,error);        }];    }  else {        onSuccessHandler(Nil,[self createErrorWithDescription:@"Patient Validation Failed" andErrorCodeNumber:kCreateNewObject inDomain:@"PatientObject"]);    }}-(NSString *)getSex{    [self linkPatient];    return (patient.sex.intValue == 0)?@"Female":@"Male";}-(NSManagedObject *)getDBObject{    [self linkPatient];    return patient;}-(void)setPhoto:(UIImage*)image{    [self linkPatient];    [patient setPhoto:[image convertImageToPNGBinaryData]];}- (NSInteger)getAge{    [self linkPatient];    return [patient.age getNumberOfYearsElapseFromDate];}-(NSString *)getDateOfBirth{    [self linkPatient];    return [patient.age convertNSDateFullBirthdayString];}- (UIImage *)getPhoto{    return [UIImage imageWithData:patient.photo];}-(BOOL)loadPatientWithPatientID:(NSString *)patientId{}-(void)LockPatient:(ObjectResponse)response{       [patient setIsLockedBy:self.appDelegate.currentUserName];        NSMutableDictionary* dataToSend = [NSMutableDictionary dictionaryWithDictionary:[self consolidateForTransmitting:patient]];        [dataToSend setValue:[NSNumber numberWithInteger:kToggleObjectLock] forKey:OBJECTCOMMAND];        [dataToSend setValue:self.appDelegate.currentUserName forKey: ISLOCKEDBY];        // Send message to server    [self tryAndSendData:dataToSend withErrorToFire:^(id<BaseObjectProtocol> data, NSError *error) {        response(Nil,[self createErrorWithDescription:@"Disconnected from server. Could not lock patient" andErrorCodeNumber:kToggleObjectLock inDomain:@"PatientObject"]);    } andWithPositiveResponse:^(id data) {        response(self,nil);    }];    }-(void)UnlockPatient:(ObjectResponse)response{        [patient setIsLockedBy:@""];        NSMutableDictionary* dataToSend = [NSMutableDictionary dictionaryWithDictionary:[self consolidateForTransmitting:patient]];        [dataToSend setValue:[NSNumber numberWithInteger:kToggleObjectLock] forKey:OBJECTCOMMAND];        [dataToSend setValue:self.appDelegate.currentUserName forKey:ISLOCKEDBY];        // Send message to server    [self tryAndSendData:dataToSend withErrorToFire:^(id<BaseObjectProtocol> data, NSError *error) {        response(Nil,error);    } andWithPositiveResponse:^(id data) {        response(self,nil);    }];}#pragma mark- Internal Private Methods#pragma mark--(NSDictionary*)DictionaryReadyToCreateUser{    NSMutableDictionary* query = [[NSMutableDictionary alloc]initWithDictionary:[self consolidateForTransmitting:patient]];        [query setValue:[NSNumber numberWithInt:kPatientType] forKey:OBJECTTYPE];        [query setValue:[NSNumber numberWithInt:kCreateNewObject] forKey:OBJECTCOMMAND];        [query setValue:patient.isLockedBy forKey:ISLOCKEDBY];        return query;}-(void)CreatePatientActionSuccessfull:(StatusObject *)notification{    tempStatusObject = notification;        if (!notification) {        respondToEvent(self,[self createErrorWithDescription:@"Patient saved but was could synced with server." andErrorCodeNumber:kCreateNewObject inDomain:@"PatientObject"] );    }    else if (tempStatusObject.status == kSuccess) {        // Activate the callback so user knows it was successful        respondToEvent(self, nil);    }else{        respondToEvent(nil,[self createErrorWithDescription:tempStatusObject.errorMessage andErrorCodeNumber:kCreateNewObject inDomain:@"PatientObject"] );    }}-(void)QueryForPatientActionSuccessfull:(StatusObject *)notification{    if (!notification) {        respondToEvent(nil, [self createErrorWithDescription:@"Search result may be incomplete due to lost connection with the server" andErrorCodeNumber:10 inDomain:@"PatientObject"]);    }else if (tempStatusObject.status == kSuccess) {        // Activate the callback so user knows it was successful         tempStatusObject = notification;        [self SaveListOfPatientsToTheDatabase:tempStatusObject.data];        respondToEvent(self, nil);    }else{        respondToEvent(nil,[self createErrorWithDescription:tempStatusObject.errorMessage andErrorCodeNumber:10 inDomain:@"PatientObject"] );    }        // Remove event listener    //[[NSNotificationCenter defaultCenter]removeObserver:self];}-(void)SaveListOfPatientsToTheDatabase:(NSDictionary*)patientList{    [self linkPatient];    // get all the users returned from server    NSArray* arr = [patientList objectForKey:ALLPATIENTS];        // Go through all users in array    for (NSDictionary* dict in arr) {        // If the user doesnt exists in the database currently then add it in        if (![self loadPatientWithPatientID:[dict objectForKey:PATIENTID]]) {            patient = (Patients*)[self CreateANewObjectFromClass:DATABASE isTemporary:NO];        }                [patient setValuesForKeysWithDictionary:dict];        [self SaveCurrentObjectToDatabase];    }}-(BOOL)isValidateIfPatientInformationIsPresent{    [self linkPatient];    patient.firstName =  [patient.firstName  stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];        patient.familyName =  [patient.familyName stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];        // Check for patientID    if (!patient.patientId.isNotEmpty) {        // Adds an ID if it is not present        patient.patientId = [NSString stringWithFormat:@"%@.%@.%f",patient.firstName,patient.familyName,[[NSDate date]timeIntervalSince1970]];    }else{        return NO;    }    if (!patient.firstName.isNotEmpty) {        return NO;    }else if (!patient.familyName.isNotEmpty){        return NO;    }else if(!patient.patientId.isNotEmpty){        return NO;    }else{        return YES;    }    }-(NSArray*)getAllVisitsForCurrentPatient{    [self linkPatient];        NSMutableArray* arr = [[NSMutableArray alloc]initWithCapacity:patient.visit.count];        for (Visitation* visit in patient.visit) {        [arr addObject:visit];    }    return  arr;}-(void)linkPatient{    patient = (Patients*)self.databaseObject;}//TODO: Need a method to push all patients to the server@end